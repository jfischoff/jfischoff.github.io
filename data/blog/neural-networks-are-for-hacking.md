In the idealized version of software development, programmers are applied mathematicians. The development process starts with a rigorous specification. Then the software is written and there is a proof that demonstrates the code implements the specification. Dijkstra would be proud.

But in the real world, this is bullshit.

In the real world, maybe there are requirements, then the software is written, maybe it is tested and only after being used for a long time do we learn what the code actually does.

In the past, software development ideas were expressed through academic papers, but this changed in the 80s and 90s as software development started to explode. People become expert programmers, not by applying theory, but by doing it. It turns out you can become an expert programmer primarily by writing a lot of code. At some point, programmers dropped the pretense they were scientists.

Programming went from an academic discipline to a craft, millions learned to programmed and software transformed the world.

## Neural Networks are a Craft

Neural network development seems like some advanced mathematics. For one, everyone seems to hold a PhD. that makes them. They use complex math like tensors and stochastic gradient descent. New developments are published in academic papers, etc, etc.

I can only imagine this is similar to how software development must have looked from the outside in the 60s and 70s.

Neural networks, which are differentialable pipelines of linear and simple monotonic non-linear functions, are exploding in utility, in part because programmers can try out different pipelines without having to apply difficult mathematical reasoning.

You can play with neural networks and get an intuitive sense for how to use them effectively, even without completely understanding the theory. Neural networks are for hacking, they're not for precise mathematical reasoning.

What we are seeing now, is similar to what happened in the 80s and 90s. Neural networks are escaping the Ivory Tower. You can become a good deep learning practitioner by trying things. If it appears to work, you can see if it works in a wider class of tests. Maybe it works well enough to make money.

Do you know exactly what a neural network can compute for all inputs? No, you don't, which is just like regularly programming. You have to deploy it and find out.

## FAFO

Neural networks are less a mathematical solution to a problem, and more a fuzzy way to program. They're useful when errors are tolerable, and it is not clear how to write a direct algorithm. Just like with regular programming, there often isn't a right answer. There is merely a solution that might work for your purposes and to know for sure you have to try it out.
